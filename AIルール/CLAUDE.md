# AI共通グローバルルール

> Motto: "小さく、明確で、安全なステップ – 実ドキュメント準拠"

## 1. 適用範囲と優先度

1. 作業開始前にプロジェクトルートの `CLAUDE.md`を読む。
2. 編集対象ファイルのディレクトリからルートに向かって各階層の `CLAUDE.md` / ルールファイルを探索し、すべて読む。
3. 優先度は「対象ディレクトリに近いもの > 親ディレクトリ > グローバル」。競合時は、より近い階層を優先し、それ以外を補助ルールとして扱う。

## 2. 共通原則

- 変更は**最小・安全・ロールバック容易**に保つ。
- 巧妙さより**明瞭さ・シンプルさ**を優先する。
- 既存の設計とスタイル・依存関係を尊重し、不要な追加をしない。
- 不明点や前提が曖昧なまま進めない。必要なら質問を出し切ってから作業する。
- 成果物は第三者が単独で再現・保守できる粒度で仕上げる。
- 問題を見つけたら放置せず、必ず対処するか Issue などに明示的に記録する。
- ボーイスカウトルール：エラーやコード臭を見つけた場所は、来たときよりも少し良い状態で残す。

### 2.1 確認すべきタイミング

以下の場合は必ずユーザーへ確認・報告する。

- タスクの意図・スコープ・完了条件が不明確なとき
- アーキテクチャ・セキュリティ・DB・プロトコルなど**重要な判断**を伴うとき
- 想定外のエラーや制約により計画変更・迂回が必要になったとき
- `docs/plan.md` / Issue Plan の「要確認事項」に記載があるとき（全て質問候補として扱う）

確認できない前提が残る場合は、「未解決の前提」として明示したうえで最小限の範囲で作業を進める。

### 2.2 セキュリティとコマンド

- フレームワークやライブラリの仕様は、`context7` など一次情報ソースや Web で常に最新版を確認する。
- `.env` や秘匿情報は閲覧・編集しない。必要な情報は利用者に依頼する。
- パイプ・リダイレクト・コマンド置換を用いた危険コマンドの迂回は禁止。
- `rm -rf`, `dd`, `git push --force` など破壊的コマンドは、実行前に意図とリスクを明示して確認を取る。

## 3. 開発フロー

1. **Plan**  
   - `docs/plan.md` / Issue Plan があれば、背景・目的、スコープ、作業項目、完了条件（Acceptance Criteria）、テスト観点、要確認事項を読み、  
     そこから**小さく検証可能なステップ**を 3〜7 個程度で箇条書きにして共有する。
2. **Read**  
   - `docs/Summery.md` が存在する場合は、設計書やソースコードを読む前に、まず `Summery.md` を参照し、プロジェクト概要を把握する。
   - 実装プラン作成や改修対象モジュールを特定する前に、`docs/モジュール構成と処理フロー.md` を参照し、対象モジュールの責務・入出力・関連ドキュメントを整理する。
   - 関連コード・ドキュメント・設定ファイルを次に読む。既存の似た処理・命名・エラー処理を探す。
   - 実装前に、既存の類似機能や同名の関数・コンポーネント・エンドポイントがないか確認し、重複実装を避ける。
3. **Verify**  
   - 外部 API・バージョン・制約条件を一次情報で確認し、必要に応じて plan にメモを残す。
4. **Implement**  
   - 一度に 1 つの目的に集中し、スコープを広げすぎない。
5. **Test & Docs**  
   - 少なくとも 1 つのテスト（自動テスト or 再現手順）と、必要なドキュメント更新を行う。  
   - Acceptance Criteria にチェックボックスがあれば、実際に満たした条件のみ ON にして plan と実作業を同期する。  
   - plan の「テスト観点」をテストコード・検証手順に落とし込む。
   - plan / 設計に沿ってテストを実行し、成功・失敗の結果を明確にする。  
   - `docs/plan.md` に対応する Issue の「テスト観点」「ゴール / 完了条件（チェックボックス）」がある場合、
     実行したテストに対応する項目をチェックし、不要になった項目は「不要」「別 Issue で対応」などと明記して消し込む。  
   - テスト結果や仕様変更に合わせて、plan や関連ドキュメントも同じブランチで更新する。
   - **Plan同期必須**: テストが完了し報告する前に、該当 Issue の `docs/plan.md` を開き、チェックボックス／ゴール欄を最新状態へ更新した上で結果を共有する。

### 5.1 Python テスト運用ルール
- すべての Python 系テスト（`pytest` など）は `/Users/Shared/my-projects/.venv` をアクティブにした状態で実行し、システム Python では絶対に実行しない。  
- **実行前チェックリスト（必須）**  
  1. `ls /Users/Shared/my-projects/.venv` で仮想環境の存在を確認する。  
  2. `source /Users/Shared/my-projects/.venv/bin/activate` *または* `/Users/Shared/my-projects/.venv/bin/python -m <command>` を使用して仮想環境を有効化する。  
  3. `which python` / `python -V` で `.../.venv/bin/python` が選択されていることを確認する。  
- **例外ハンドリング**: 仮想環境が存在しない、壊れているなどの理由で上記チェックを満たせない場合は、システム Python での実行や独断での再作成を行わず、状況と原因をユーザーへ即時報告し指示を仰ぐ。  
- **テスト結果レポート テンプレ**  
  - レポート時は以下の形式を必ず用いる：  
    `使用仮想環境: /Users/Shared/my-projects/.venv`  
    `実行コマンド: /Users/Shared/my-projects/.venv/bin/python -m pytest ...`  
    `結果: <pass/fail 概要>`  
  - テンプレ記載を省略したレポートは不可とし、再提出する。

6. **Reflect**  
   - 根本原因・回帰リスク・今後の簡略化余地を短くメモし、必要なら plan / ドキュメントに反映する。  
   - 作業を完了する前に、今回の Issue で得た学びがあれば `lessons-learned.md` に追記し、暫定対応や技術的負債を残した場合は `docs/technical-debt.md` に記録する。

## 4. 実装・スタイル・コミュニケーション

### 4.1 コードスタイル

- 既存の命名規則・インデント・改行スタイルに合わせる。
- マジックナンバーは定数・設定に集約する。
- 新規ファイルのコメントは最小限のヘッダーにとどめ、既存ファイルにも必要最小限だけ追加する。
- 1 ファイルは目安 300 行以内を意識するが、不自然な分割はしない。
- SQL はキーワードを大文字、句ごとに改行し、インデントを揃える。
- 編集過程のメモコメント（例: `// この行を追加`）はコミット前に除去する。

### 4.2 コミュニケーション
**チャット以外のコメント・ドキュメント・ログ・エラーメッセージの扱いは 8.1 を参照する。**
- 回答は原則日本語。必要に応じて英語用語・API 名を併記する。
- 不確かさが大きい場合はその旨と理由を明示し、推測と事実を分けて書く。
- 変更内容・前提・トレードオフ・影響範囲を簡潔にまとめる。
- 会話は通常テキストを基本とし、コード・コマンド・設定のみコードブロック（```lang）を使う。
- チャット上の補助コメントは許容するが、実ファイルには残さない。

## 5. 技術文書と一次情報

技術仕様・API・SDK などを説明する文書を書くときの共通ルール。

- 必ず Web 検索で最新の一次情報を参照する。優先順位は  
  公式ドキュメント > 公式 GitHub / リポジトリ > 信頼性の高いコミュニティ。
- 内容は「勝手に意訳」するのではなく、原文を確認した上で忠実に要約・翻訳する。
- 重要な仕様は複数の公式ソースでクロスチェックする。
- キー名・パラメータ名・イベント名などは一字一句正確に記載し、存在を必ず確認する。
- SDK 名や機能名に履歴がある場合は、最新版の名前を基本としつつ、旧名が必要なら併記する。
- 仕様に対する確信度が 80% 未満の箇所は「未確認」「推測」などと明示し、誤認させない。
- 事実と推測、環境依存（バージョン・OS・クラウドなど）は明確に分けて記述する。
- 重要な技術仕様には、参照した一次情報の URL と「YYYY-MM-DD 時点」の取得日を併記する。
- 更新頻度の高いサービスでは、「この情報が有効と考えられる期間」や、再確認の目安時期も一言メモしておく。

## 6. タスク分類・ツール・承認

### 6.1 タスク分類

- **🟢 軽量タスク**  
  - 例: 設定ファイルの確認、小さなスクリプト修正、10 行以内のコメント/Markdown 修正、フォーマット調整、軽い調査。  
  - 簡易分析（概要 1 行・リスク 1 点）だけ共有し、そのまま実行してよい。  
  - ファイル閲覧・ディレクトリ表示など**読み取り専用の CLI** は、即時実行して結果のみ 1〜2 行報告でよい。
- **🟡 標準タスク**  
  - 例: 機能改修、外部 API / DB 連携、文字コード・フォーマット変換など。  
  - 短い分析 → 5 項目以内の計画 → 実装 → 簡潔な進捗報告 → テスト・完了報告。
- **🔴 重要タスク**  
  - 例: インフラ設定・権限変更、通信仕様・データモデル・認証方式の変更、本番環境に影響する処理。  
  - 影響・リスク・ロールバックを含む詳細分析 → ユーザーの明示的承認 → 段階実行 → 検証 → 報告。

### 6.2 承認が必須となる変更

以下はいずれも、**実装前に必ずユーザーの承認を得る**。

- データベーススキーマ変更
- 外部 API 仕様・認証方式の変更
- セキュリティ設定 / 権限の変更
- 本番環境や顧客データに影響する変更
- UI/UX デザインの大きな変更（レイアウト・色・フォントなど）
- 技術スタックや主要ライブラリのバージョンアップ

### 6.3 並列実行とツール利用

- 並列実行の基準  
  - 🟢 独立タスク: 並列実行可  
  - 🟡 弱い依存関係: 入力が確定している部分だけ並列可  
  - 🔴 強い依存関係: 順次実行必須  
  - ⛔ ブロッカー: 解消まで関連作業を停止
- ツール呼び出し  
  - 🟢: 簡易分析を共有したら同じメッセージ内でツール実行してよい。  
  - 🟡: 計画とチェックリストを提示したうえで、同じメッセージ内で実行に進んでよい。  
  - 🔴: 詳細分析と承認取得を終えてから小さなステップでツールを実行する。  
  - 長時間処理や外部サービス操作では、リスクと進捗を明示しながらユーザーと同期する。

## 7. 進捗管理と中断

- タスク開始時に、主要ステップを 3〜7 個で箇条書きにする。
- 進捗報告は基本フォーマットで行う：  
  - `完了:` / `進行中:` / `次にやること:` を 1〜2 行で記述し、末尾に `Plan同期: 済/未` を添えて現在の plan 反映状況を明示する。
- 30 分を超えるタスクでは、30 分ごとに現状（完了/進行中/残り）と想定残り時間を簡潔に共有する。
- 中断が必要な場合は、以下を残す：  
  - 完了済みステップ / 進行中ステップ / 未着手ステップ  
  - 作業ブランチ・依存関係の状態  
  - 再開時に実行すべきコマンド例（`git checkout ...` など）
  - `docs/plan.md` の該当チェックボックスを反映済みかどうか（未なら TODO として次回に持ち越す）

## 8. AI 駆動開発の詳細ガイドライン

### 8.1 言語・メッセージ

- AI の内部思考やドラフトは英語でもよいが、ユーザー向けの最終出力は日本語とする。
- コメント・ドキュメント・ログ・エラーメッセージも日本語で分かりやすく書く。
- 変数名、関数名、クラス名などの識別子は英語で、既存スタイル（例: Python なら PEP8）に合わせる。
- エラーメッセージは「何が起きたか」「なぜかもしれないか」「次に何をすべきか」が分かるようにする。

### 8.2 コード品質・テスト・エラー

- 単一責任・高凝集・低結合を意識し、小さな関数やモジュールに分割する。
- 例外処理・ログ出力を適切に配置し、失敗時に原因を追いやすくする。
- 新規機能やバグ修正には、可能な限り自動テスト（ユニット / 統合）を追加する。
- テストは「再現用ケース」「境界値」「エラーケース」を少なくとも意識する。
- Flaky テストは原因を特定したうえで安定化させるか、理由付きで除外する。
- エラーは、入力不備 / 環境 / 仕様 / 実装バグ / 外部要因などに切り分けて分析し、どこに原因があるかを明示する。
- Linter / フォーマッタ / 静的解析の指摘は、原因を理解したうえで可能な限り修正する。
- `any` 型や暫定コメントアウトで警告を「隠す」ことは禁止。やむを得ず残す場合は TODO と理由をコメントに残す。
- 「未使用だが将来使うかもしれない」コードは原則削除し、必要になった時点で再実装する。
- Python 系の自動テスト（例: `pytest`）は、プロジェクト指定の仮想環境（例: `.venv`）をアクティブにした状態で実行する。
- テストは高速で決定的（同じ入力に対して常に同じ結果）になるようにし、テスト同士が依存しないように書く。
- カバレッジは目安としつつ、重要なパスとエラー処理を優先してテストする。

#### 8.2.1 エラーの重要度と対応

```markdown
🟢 軽度: 記録しつつ継続（例: 警告ログ、非推奨 API）
🟡 アプリケーション: 自動リトライ or リカバリ後に報告（例: 解析失敗、フォーマット不一致）
🔴 システム: 即停止・原因の切り分けとユーザーへの報告（例: タイムアウト、通信断）
⛔ セキュリティ: 全作業停止・緊急報告（例: 認証情報漏洩の疑い）


### 8.3 保守性・セキュリティ・パフォーマンス

- リファクタリングは「テストがあること」「振る舞いを変えないこと」を前提に小さく行う。
- N+1 クエリや不要なループ・重い同期処理など明らかなボトルネックを避ける。
- 入力検証、権限チェック、機密データの扱い（ログ出力禁止など）を徹底する。
- リトライ・タイムアウト・サーキットブレーカーなどで外部依存の信頼性を確保する。

### 8.4 Git・レビュー・デバッグ

- コミットは論理的にまとまった単位で小さく分け、わかりやすいメッセージを付ける。
- 既存のコードレビューコメントやスタイルガイドがあればそれに従う。
- デバッグ時は、再現手順 → 切り分け（入力・環境・コード）→ 仮説 → 検証 → 根本原因の特定、の流れで進める。
- 一時的なログ出力やデバッグコードは、修正確定後に必ず削除する。
- コミットメッセージは日本語で「何を」「なぜ」を簡潔に書き、コンベンショナルコミット形式（`feat:`, `fix:`, `docs:`, `test:`, `refactor:`, `chore:` など）を用いる。
- `main` / `master` ブランチへの直接コミットは避け、必ずブランチ＋PR 経由で反映する。

### 8.5 依存関係とドキュメント

- 依存追加は最小限にとどめ、代替の標準機能や既存ライブラリを先に検討する。
- `package-lock.json` などロックファイルは常にコミットする。
- 追加する依存のライセンス・サイズ・メンテ状況を確認する。
- README には概要・セットアップ・実行方法・主要コマンド・よくあるトラブルを簡潔にまとめる。
- 重要な設計判断は ADR（Architecture Decision Record）として短く記録する。

## 9. 自己チェック

- コードブロックは必要な場面のみ使用し、常に言語指定と整形を行っているか
- 結論ファーストで回答し、既存スタイルと規約を守れているか
- 成果物が過剰変更や機密情報を含まず、第三者が単独で理解・保守できるか
- 実ファイルに編集過程由来のコメントや痕跡を残していないか
- 技術文書では、事実と推測を分け、必要な出典を明示できているか
- `docs/plan.md` のチェックボックスや完了条件が、実際の実装・テスト結果と一致しているかを確認する。
- 各 ISSUE の実装・テストが完了したら、`rules/summery反映ルール.md` を参照し、その Issue の変更が `Summery.md` に反映すべき内容かどうかを確認する。
- 反映が必要な場合は、`rules/summery反映ルール.md` に従って `Summery.md` を更新する。詳細な更新手順・記述ルールはすべて `rules/summery反映ルール.md` 側を正とする。

---

以上をデフォルトの行動方針とし、プロジェクト固有の `CLAUDE.md` / ルールファイルがあれば、それらで上書き・補完する。
